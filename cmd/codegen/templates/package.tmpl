{{/* Copyright 2026 Franklin "Snaipe" Mathieu.

 Use of this source code is governed by the MIT license that can be
 found in the LICENSE file. */-}}

// This file was automatically generated by snai.pe/go-varlink/codegen
// DO NOT EDIT

{{ include "comments" .Interface -}}
package {{ .PkgName | default (split .Interface.Name "." | last | camelCase) }}

import (
	"context"
	"encoding/json"
	"fmt"

{{ if or .GenClient .GenService .GenTypes -}}
	"snai.pe/go-varlink"
{{- end }}
{{ if .GenMeta }}
	"snai.pe/go-varlink/syntax"
{{ end }}
)

var _ = fmt.Errorf
var _ = json.RawMessage(nil)
var _ = context.Background

// InterfaceName is the fully-qualified name of this varlink interface.
const InterfaceName = `{{ .Interface.Name }}`

{{ if .GenTypes -}}
{{ range .Interface.Types }}
{{- $typename := pascalCase .Name }}
{{ include "comments" . -}}
type {{ $typename }} {{ include "type" .Type -}}

{{ with enum .Type }}
const (
{{ range .Values -}}
{{ include "comments" . -}}
{{ $typename }}{{ pascalCase .Name }} {{ $typename }} = "{{ .Name }}"
{{ end }}
)

func (e {{ $typename }}) Validate(param string) varlink.Error {
	switch e {
	{{ range .Values -}}
	case {{ $typename }}{{ pascalCase .Name }}:
	{{ end -}}
	default:
		return varlink.NewError("org.varlink.service.InvalidParameter", "parameter", param)
	}
	return nil
}

func (e *{{ $typename }}) UnmarshalJSON(data []byte) error {
	*e = {{ $typename }}(data)
	return e.Validate()
}

func (e {{ $typename }}) MarshalJSON() ([]byte, error) {
	if err := e.Validate(); err != nil {
		return nil, err
	}
	return []byte(e), nil
}
{{- end }}
{{ end }}

{{ range .Interface.Methods -}}
{{ $method := . }}
// Input parameters for {{ .Name }} method.
//
// You shouldn't have to use this type directly; it is only useful if you
// need to manually send method calls. Instead, use the methods of the
// Client type.
type {{ pascalCase .Name }}Input {{ include "type" .Input -}}

{{ with trim (include "validate" "input" "" .Input) }}
func (input *{{ pascalCase $method.Name }}Input) Validate(param string) varlink.Error {
	{{ . }}
	return nil
}
{{ end }}

{{ with trim (include "args" .Input) }}
// Pack fills in the fields of {{ pascalCase $method.Name }}Input from a
// parameter list.
func (input_ *{{ pascalCase $method.Name }}Input) Pack({{ . }}) {
	{{- with struct $method.Input -}}
	{{- range $i, $f := .Fields }}
	input_.{{ pascalCase $f.Name }} = {{ escapekw (camelCase $f.Name) }}
	{{- end -}}
	{{- end }}
}

// Unpack unpacks the fields of {{ pascalCase $method.Name }}Input to a
// parameter list.
func (input_ *{{ pascalCase $method.Name }}Input) Unpack() ({{ . }}) {
	{{- with struct $method.Input -}}
	{{- range $i, $f := .Fields }}
	{{ escapekw (camelCase $f.Name) }} = input_.{{ pascalCase $f.Name }}
	{{- end -}}
	{{- end }}
	return
}
{{ end }}

// Output parameters for {{ .Name }} method.
//
// You shouldn't have to use this type directly; it is only useful if you
// need to manually send method calls. Instead, use the methods of the
// Client type.
type {{ pascalCase .Name }}Output {{ include "type" .Output -}}

{{ with trim (include "validate" "output" "" .Output) }}
func (output *{{ pascalCase $method.Name }}Output) Validate(param string) varlink.Error {
	{{ . }}
	return nil
}
{{ end }}

{{ with trim (include "args" .Output) }}
// Pack fills in the fields of {{ pascalCase $method.Name }}Output from a
// parameter list.
func (output_ *{{ pascalCase $method.Name }}Output) Pack({{ . }}) {
	{{- with struct $method.Output -}}
	{{- range $i, $f := .Fields }}
	output_.{{ pascalCase $f.Name }} = {{ escapekw (camelCase $f.Name) }}
	{{- end -}}
	{{- end }}
}

// Unpack unpacks the fields of {{ pascalCase $method.Name }}Input to a
// parameter list.
func (output_ *{{ pascalCase $method.Name }}Output) Unpack() ({{ . }}) {
	{{- with struct $method.Output -}}
	{{- range $i, $f := .Fields }}
	{{ escapekw (camelCase $f.Name) }} = output_.{{ pascalCase $f.Name }}
	{{- end -}}
	{{- end }}
	return
}
{{ end }}
{{ end }}
{{- end }}

{{ if .GenErrors -}}
{{ range .Interface.Errors -}}
{{ include "comments" . -}}
type {{ pascalCase .Name }}Error {{ include "type" .Params }}

func ({{ pascalCase .Name }}Error) ErrorCode() string {
	return `{{ $.Interface.Name }}.{{ .Name }}`
}

func ({{ pascalCase .Name }}Error) Error() string {
	return `{{ range $i, $c := .Comments }}{{ if $i }} {{ end }}{{ $c.Value }}{{ end }}`
}

func {{ pascalCase .Name }}({{ include "args" .Params }}) {{ pascalCase .Name }}Error {
	var err_ {{ .Name }}Error
	{{- with struct .Params -}}
	{{- range $i, $f := .Fields }}
	err_.{{ pascalCase $f.Name }} = {{ escapekw (camelCase $f.Name) }}
	{{- end -}}
	{{- end }}
	return err_
}
{{ end }}
{{- end }}

{{ if .GenClient -}}
// Client represents a varlink client that implements the {{ .Interface.Name }}
// interface.
type Client struct {
	varlink.Client
}

{{/*
  NOTE: ErrorFromCode cannot go into the GenErrors section of the template,
  because it requires go-varlink to be imported. However, go-varlink itself
  requires the error generation code for core org.varlink.service error types.
*/}}

// ErrorFromCode returns a new varlink error constructed from the specified
// code and parameters.
func ErrorFromCode(code string, params json.RawMessage) varlink.Error {
	switch code {
	{{- range .Interface.Errors }}
	case `{{ $.Interface.Name }}.{{ .Name }}`:
		var err_ {{ .Name }}Error
		if err2_ := json.Unmarshal([]byte(params), &err_); err2_ != nil {
			panic(`programming error: {{ $.Interface.Name }}.{{ .Name }} params is invalid json: ` + err2_.Error())
		}
		return err_
	{{ end -}}
	default:
		var kvargs []any
		var pmap map[string]any
		if err2_ := json.Unmarshal([]byte(params), &pmap); err2_ != nil {
			panic(`programming error: ` + code + ` params is invalid json: ` + err2_.Error())
		}
		for k, v := range pmap {
			kvargs = append(kvargs, k, v)
		}
		return varlink.NewError(code, kvargs...)
	}
}

{{ range .Interface.Methods -}}
{{ $inputargs := trim (include "args" .Input) }}
{{ $outputargs := trim (include "args" .Output) }}
{{ include "comments" . -}}
func (client_ *Client) {{ pascalCase .Name }}(ctx context.Context, {{ $inputargs }}) ({{ with $outputargs }}{{ . }}, {{ end }}err_ error) {
	var (
		input_ {{ pascalCase .Name }}Input
		output_ {{ pascalCase .Name }}Output
	)
	{{ if $inputargs }}
	input_.Pack({{ include "callargs" .Input }})
	{{ end }}

	rs, err := client_.Call(ctx, `{{ $.Interface.Name }}.{{ .Name }}`, &input_)
	if err != nil {
		err_ = err
		return
	}

	for rs.Next() {
		r := rs.Reply()
		if r.Error != "" {
			err_ = ErrorFromCode(r.Error, r.Parameters)
			return
		}
		if r.Continues {
			err_ = fmt.Errorf("more than one reply on single-reply call")
			return
		}

		if err := rs.Unmarshal(&output_); err != nil {
			err_ = err
			return
		}
	}
	if err := rs.Error(); err != nil {
		err_ = err
		return
	}

	{{ if $outputargs }}
	{{ include "callargs" .Output }} = output_.Unpack()
	{{ end -}}
	return
}
{{ end }}
{{- end }}

{{ if .GenService -}}
// Service is the interface that servers that implement the {{ $.Interface.Name }}
// varlink interface must adhere to.
type Service interface {
	{{ range .Interface.Methods -}}
	{{- $inputargs := trim (include "args" .Input) -}}
	{{- $outputargs := trim (include "args" .Output) -}}
	{{ include "comments" . -}}
	{{ pascalCase .Name }}(ctx context.Context, {{ $inputargs }}) ({{ with $outputargs }}{{ . }}, {{ end }}err_ varlink.Error)
	{{ end }}
}

// NewHandler creates a new method handler for the specified service implementation.
func NewHandler(s Service) varlink.MethodHandler {
	var mux varlink.ServeMux
	RegisterHandlers(&mux, s)
	return &mux
}

// RegisterHandlers registers all of the method handlers for the specified
// service implementation into the passed ServeMux.
func RegisterHandlers(mux *varlink.ServeMux, s Service) {
	{{ range .Interface.Methods -}}
	{{- $outputargs := trim (include "args" .Output) -}}
	mux.HandleFunc("{{ $.Interface.Name }}.{{ .Name }}", func(w varlink.ReplyWriter, call *varlink.Call) {
		var (
			input {{ pascalCase .Name }}Input
			output {{ pascalCase .Name }}Output
		)

		if err := call.Unmarshal(&input); err != nil {
			w.WriteError(err)
			return
		}

		validate := func() varlink.Error {
			{{ include "validate" "input" "" .Input }}
			return nil
		}
		if err := validate(); err != nil {
			w.WriteError(err)
			return
		}

		var err varlink.Error
		{{ if $outputargs }}{{ include "fields" .Output "output" }}, {{ end }}err = s.{{ pascalCase .Name }}(w.Context(), {{ include "fields" .Input "input" }})
		if err != nil {
			w.WriteError(err)
			return
		}

		w.WriteReply(&output)
	})
	{{ end -}}
}
{{- end }}

{{ if .GenMeta }}
// Definition contains the definition of the varlink interface which was parsed from its description.
var Definition = {{ gostring .Interface }}

// Description contains the description of the varlink interface, expressed in the IDL.
var Description = `{{ .Source }}`
{{ end }}
